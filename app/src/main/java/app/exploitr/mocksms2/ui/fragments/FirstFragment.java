package app.exploitr.mocksms2.ui.fragments;

import android.Manifest;
import android.app.Activity;
import android.app.DatePickerDialog;
import android.app.TimePickerDialog;
import android.app.role.RoleManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.ContactsContract;
import android.provider.Settings;
import android.provider.Telephony;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AlphaAnimation;
import android.view.animation.AnimationSet;
import android.view.animation.TranslateAnimation;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContract;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.fragment.app.Fragment;
import androidx.navigation.fragment.NavHostFragment;

import com.google.android.material.textfield.TextInputLayout;

import java.util.Calendar;

import app.exploitr.mocksms2.R;
import app.exploitr.mocksms2.data.PrefMan;
import app.exploitr.mocksms2.databinding.FragmentFirstBinding;
import app.exploitr.mocksms2.utils.SMSManager;
import app.exploitr.mocksms2.utils.Tools;

public class FirstFragment extends Fragment {

    ActivityResultLauncher<Intent> pickTac;
    private FragmentFirstBinding binding;
    private boolean isTextMonitorActive = false;

    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentFirstBinding.inflate(inflater, container, false);
        pickTac = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -> {
            if (result.getResultCode() == AppCompatActivity.RESULT_OK) {
                Intent data = result.getData();
                if (data != null) {
                    String[] projection = new String[]{ContactsContract.CommonDataKinds.Phone.NUMBER};
                    String sort = ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME_PRIMARY + " ASC";
                    Cursor cursor = getActivity().getContentResolver().query(data.getData(), projection, null, null, sort);
                    if (cursor != null && cursor.moveToFirst()) {
                        int numberIndex = cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER);
                        String number = cursor.getString(numberIndex);
                        binding.phoneTextInputEditText.setText(number.replaceAll("\\s+", ""));
                        cursor.close();
                    }
                } else {
                    Toast.makeText(getContext(), "Invalid Number", Toast.LENGTH_SHORT).show();
                }
            }
        });
        return binding.getRoot();
    }

    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);

        binding.modeSelectGroup.addOnButtonCheckedListener((group, checkedId, isChecked) -> animateAndSet(isChecked, checkedId));
        binding.dateTimeView.setOnClickListener(v -> changeTimeAndDate());
        binding.fab.setOnClickListener(view_ -> NavHostFragment.findNavController(FirstFragment.this).navigate(R.id.action_FirstFragment_to_SecondFragment));

        binding.phoneTextInputLayout.setEndIconOnClickListener(v -> {
            if (ContextCompat.checkSelfPermission(requireContext(), Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED)
                ActivityCompat.requestPermissions(requireActivity(), new String[]{Manifest.permission.READ_CONTACTS}, 1);
            else openContactPicker();
        });

        ActivityResultLauncher<Void> changeDefaultSmsLauncher = registerForActivityResult(new ChangeDefaultSmsContract(), result -> {
            if (result) {
                Toast.makeText(getContext(), "Default SMS set", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(getContext(), "Default SMS set", Toast.LENGTH_SHORT).show();
            }
        });

        binding.setDefaultButton.setOnClickListener(v -> changeDefaultSmsLauncher.launch(null));
        binding.createSmsButton.setOnClickListener(v -> startSmsSaveProcess());
    }

    private void startSmsSaveProcess() {
        if (!isTextMonitorActive) enableTextInputMonitor();

        String phone = binding.phoneTextInputEditText.getText() == null ? "" : binding.phoneTextInputEditText.getText().toString();
        boolean phone_ok = phone.length() > 1 && Tools.isVerifiedValidPhoneNumber(phone);
        manage_error_display(binding.phoneTextInputLayout, "Invalid Phone Number!", phone_ok);

        String message = binding.smsBodyInputEditText.getText() == null ? "" : binding.smsBodyInputEditText.getText().toString();
        boolean message_ok = !message.isEmpty();
        manage_error_display(binding.smsBodyInputLayout, "Message cannot be empty!", message_ok);

        if (phone_ok && message_ok) SMSManager.saveSMS(phone, message);
    }

    private void manage_error_display(TextInputLayout layout, String text, boolean condition) {
        if (condition) layout.setErrorEnabled(false);
        else {
            layout.setError(text + " " + new String(Character.toChars(9888)));
            layout.setErrorIconDrawable(null);
            layout.setErrorEnabled(true);
        }
    }

    private void enableTextInputMonitor() {
        isTextMonitorActive = true;
        binding.phoneTextInputEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {

            }

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {

            }

            @Override
            public void afterTextChanged(Editable s) {
                String phone = s == null ? "" : s.toString();
                boolean phone_ok = phone.length() > 1 && Tools.isVerifiedValidPhoneNumber(phone);
                manage_error_display(binding.phoneTextInputLayout, "Invalid Phone Number!", phone_ok);
            }
        });

        binding.smsBodyInputEditText.addTextChangedListener(new TextWatcher() {
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {

            }

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {

            }

            @Override
            public void afterTextChanged(Editable s) {
                String message = s == null ? "" : s.toString();
                boolean message_ok = !message.isEmpty();
                manage_error_display(binding.smsBodyInputLayout, "Message cannot be empty!", message_ok);
            }
        });
    }

    private void openContactPicker() {
        Intent intent = new Intent(Intent.ACTION_PICK);
        intent.setType(ContactsContract.CommonDataKinds.Phone.CONTENT_TYPE);
        pickTac.launch(intent);
    }

    private void changeTimeAndDate() {
        Calendar calendar = Calendar.getInstance();

        TimePickerDialog timePickerDialog = new TimePickerDialog(getActivity(), (timePicker, hourOfDay, minute) -> {
            calendar.set(Calendar.HOUR_OF_DAY, hourOfDay);
            calendar.set(Calendar.MINUTE, minute);
            if (getActivity() != null && !getActivity().isFinishing()) {
                DatePickerDialog datePickerDialog = new DatePickerDialog(getActivity(), (datePicker, year, month, dayOfMonth) -> binding.dateTimeView.updateDateTime(hourOfDay, minute, year, month, dayOfMonth), calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH));
                datePickerDialog.show();
            }
        }, calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), true);

        timePickerDialog.show();
    }


    private void animateAndSet(boolean isChecked, int checkedId) {
        if (!isChecked) return;
        String hintText;
        if (checkedId == R.id.inbox_button) hintText = "Mode > Inbox";
        else if (checkedId == R.id.sent_button) hintText = "Mode > Sent";
        else if (checkedId == R.id.draft_button) hintText = "Mode > Draft";
        else if (checkedId == R.id.outbox_button) hintText = "Mode > Outbox";
        else if (checkedId == R.id.failed_button) hintText = "Mode > Failed";
        else if (checkedId == R.id.queued_button) hintText = "Mode > Queued";
        else hintText = "Unknown err!";

        binding.hintMode.setText(hintText);

        int[] toggleButtonGroupLocation = new int[2];
        binding.modeSelectGroup.getLocationOnScreen(toggleButtonGroupLocation);

        int[] textViewLocation = new int[2];
        binding.hintMode.getLocationOnScreen(textViewLocation);

        float yDelta = toggleButtonGroupLocation[1] - textViewLocation[1];

        AnimationSet animationSet = new AnimationSet(true);

        TranslateAnimation translateAnimation = new TranslateAnimation(0, 0, yDelta, 0);
        translateAnimation.setDuration(250);
        animationSet.addAnimation(translateAnimation);

        AlphaAnimation alphaAnimation = new AlphaAnimation(0, 1);
        alphaAnimation.setDuration(250);
        animationSet.addAnimation(alphaAnimation);

        binding.hintMode.startAnimation(animationSet);
    }

    @Override
    public void onDestroyView() {
        super.onDestroyView();
        binding = null;
    }

    @Override
    public void onResume() {
        super.onResume();
        enableTextInputMonitor();
        new Handler(Looper.getMainLooper()).postDelayed(() -> {
            binding.phoneTextInputLayout.setErrorIconDrawable(null);
            binding.smsBodyInputLayout.setErrorIconDrawable(null);
        }, 100); //weird fix but it works!
    }

    class ChangeDefaultSmsContract extends ActivityResultContract<Void, Boolean> {
        @NonNull
        @Override
        public Intent createIntent(@NonNull Context context, Void input) {
            Intent roleRequestIntent;
            if (Build.VERSION.SDK_INT > Build.VERSION_CODES.P) {
                RoleManager roleManager = (RoleManager) getContext().getSystemService(Context.ROLE_SERVICE);
                if (roleManager.isRoleHeld(RoleManager.ROLE_SMS))
                    roleRequestIntent = new Intent(Settings.ACTION_MANAGE_DEFAULT_APPS_SETTINGS);
                else roleRequestIntent = roleManager.createRequestRoleIntent(RoleManager.ROLE_SMS);
            } else {
                roleRequestIntent = new Intent(Telephony.Sms.Intents.ACTION_CHANGE_DEFAULT);

                if (Telephony.Sms.getDefaultSmsPackage(getContext()).equalsIgnoreCase(requireContext().getPackageName()))
                    roleRequestIntent.putExtra(Telephony.Sms.Intents.EXTRA_PACKAGE_NAME, PrefMan.getInstance(getContext()).getDefaultSmsPackage());
                else
                    roleRequestIntent.putExtra(Telephony.Sms.Intents.EXTRA_PACKAGE_NAME, requireContext().getPackageName());
            }
            return roleRequestIntent;
        }

        @Override
        public Boolean parseResult(int resultCode, Intent intent) {
            return resultCode == Activity.RESULT_OK;
        }
    }
}